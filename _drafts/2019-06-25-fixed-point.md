---
layout: post
title: 计算机组成 - 定点数的表示和运算
categories: Computer
description: 本文记述了计算机系统中数据的表示形式
keywords: Computer
mathjax: true
---

定点数是指计算机中采用的一种数的表示方法。参与运算的数的小数点位置固定不变。

* TOC
{:toc}

# 表示

## 正负表示

真值存在着正负的区别，而机器数是二进制序列，并不存在正负号，因此有以下规定：  
将二进制序列中第一位设置为符号位，符号位为 0 表示正数，1 则表示负数

## 小数表示

小数点约定在固定位置的数叫做**定点数**： 

* 最后：定点整数

* 最前：定点小数

计算机并不消耗一位来存储小数点，对于定点数，机器默认小数点在最前或最后，即：

* 定点小数：`符号位 - 默认小数点 - 值` = S (.)XXX XXXX

* 定点整数：`符号位 - 值 - 默认小数点` = S XXX XXXX(.)

## 定点数的编码表示

将定点数从真值转化为机器数，有以下几个过程：

* 原码：真值的二进制形式，存在两个零，且加减存在问题

* 反码：统一了加减法运算，但存在两个零

* 补码：采用模运算的方式解决两个零和加减的问题

* 移码：浮点数中的阶是定点数，简化浮点数运算中的“对阶”操作

### 规则

编码 | 规则 | 126 | -43
:-: | :- | :-: | :-:
原码 | 符号位 0 为负数，1 为正数，数值位为真值的二进制 | 0 1111110 | 1 0101011
反码 | 正数不变，负数为原码的数值位取反 | 0 1111110 | 1 1010100
补码 | 正数不变，负数为反码的数值位加一 | 0 1111110 | 1 1010101
移码 | 对于定点整数，加上偏置常数 2<sup>n-1</sup> | 1111 1110 | 0101 0101

### 对照表

机器数 | 无符号数 | 原码 | 反码 | 补码 | 移码
:-: | :-: | :-: | :-: | :-: | :-: 
0000 0000 | 0 | +0 | +0 | 0 | -128
0000 0001 | 1 | 1 | 1 | 1 | -127
0000 0010 | 2 | 2 | 2 | 2 | -126
... | ... | ... | ... | ... | ...
0111 1101 | 125 | 125 | 125 | 125 | -3
0111 1110 | 126 | 126 | 126 | 126 | -2
0111 1111 | 127 | 127 | 127 | 127 | -1
1000 0000 | 128 | -0 | -127 | -128 | 0
1000 0001 | 129 | -1 | -126 | -127 | 1
... | ... | ... | ... | ... | ...
1111 1101 | 253 | -125 | -2 | -3 | 125
1111 1110 | 254 | -126 | -1 | -2 | 126
1111 1111 | 255 | -127 | -0 | -1 | 127

**根据数的编码求相反数的编码：**

* 原码：符号位取反

* 反码：全部取反

* 补码：全部取反再加一(由于补码是在反码基础上负数全部后移一位，特殊：-128)

* 移码：全部取反再加一(由于移码是在补码基础是全部后移2<sup>n-1</sup>位，特殊：-128)

## 定点数的运算

### 移位

对象 | 方法 | 具体描述
:-: | :-: | :-
无符号数 | 逻辑移位 | 溢出位丢弃，缺失位补 0
有符号数 | 算术移位 | 空位添补规则

* 空位添补规则：  
  
  正负 | 码制 | 添补代码
  :-: | :-: | :-:
  正数 | 所有 | 0
  负数 | 原码 | 0
  负数 | 反码 | 1
  负数 | 补码 | 左移添 0 右移添 1

### 加减

* [A + B]<sub>补</sub> = [A]<sub>补</sub> + [B]<sub>补</sub>

* [A - B]<sub>补</sub> = [A]<sub>补</sub> + [-B]<sub>补</sub>

### 溢出判断

直接的加减运算和移位运算将存在溢出的问题，有三种方法判断溢出：

* 溢出逻辑表达式：
$$V=(A_SB_S\overline {S_S}) + (\overline {A_S}\overline {B_S}S_S).$$  
若 V 为 1，则溢出

* 对比符号位与数值位的进位：  
  
    情况 | 符号位是否进位$$C_S$$ | 数值位是否进位$$C_1$$
    :-: | :-: | :-: 
    正溢出 | 否 | 是
    负溢出 | 是 | 否
  
  $$V=C_S\oplus C_1$$，若 V 为 1，则溢出

* 双符号位判断溢出：  
  
  在进行运算时，系统并行传输一位二进制与原机器数组成双符号位的操作数：正数为 00、负数为 11  
  若运算结束后，双符号位不同，则表示溢出  
  
  双符号位同时可用于移位运算，高符号位为真正的符号，低符号位参与移位运算，若运算结束二者不同，则表示溢出

### 乘法

#### 原码一位乘法

* 符号位：$$P_S=X_S\oplus Y_S$$

* 数值位：采用 ACC 和 MQ 同时处理运算的方式求出  
  
  ![原码一位乘法](https://zoharyip.club/images/posts/原码一位乘法.png "原码一位乘法")

#### 补码一位乘法

采用 [布斯(Booth)乘法](https://baike.baidu.com/item/布斯乘法算法)

### 除法

* 原码恢复余数法

* 原码加减交替法

* 补码加减交替法

除法类型 | 符号位参与运算 | 加减次数 | 移位方向 | 移位次数 | 说明
:-: | :-: | :-: | :-: | :-: | :-
原码加减交替法 | 否 | N+1 或 N+2 | 左 | N | 若最终余数为负，则恢复余数
补码加减交替法 | 是 | N+1 | 左 | N | 商末位置恒置 1

## 强制类型转换

### 有符号数转换为无符号数

不改变所存储的内容，改变解释方式，直接解释为无符号类型：

原有符号整数：(-4321)<sub>10</sub> = [1110 1111 0001 1111]‬<sub>补</sub>

转无符号整数：[1110 1111 0001 1111]‬<sub>原</sub> = (‭61215‬)<sub>10</sub>

### 长字节类型转短字节类型

高位截断，低位保留：

原 2 字节整数：(-4321)<sub>10</sub> = [1110 1111 0001 1111]‬<sub>补</sub>

转 1 字节整数：[0001 1111]‬<sub>补</sub> = (‭31‬)<sub>10</sub>

### 短字节类型转长字节类型

符号扩展：符号位是多少，就在前面补多少

原 2 字节整数：(-4321)<sub>10</sub> = [1110 1111 0001 1111]‬<sub>补</sub>

转 4 字节整数：[1111 1111 1111 1111 1110 1111 0001 1111]<sub>补</sub> = (-4321)<sub>10</sub>

原 2 字节整数：(4321)<sub>10</sub> = [0001 0000 1110 0001]‬<sub>补</sub>

转 4 字节整数：[0000 0000 0000 0000 0001 0000 1110 0001]<sub>补</sub> = (4321)<sub>10</sub>