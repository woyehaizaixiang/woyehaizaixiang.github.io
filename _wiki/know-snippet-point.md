---
layout: wiki
title: 通用的语言知识
description: 分散的知识点慢慢聚集起来会是什么情景呢?
date: 2019-04-05
categories: Others
---

**目录**

* TOC
{:toc}

## 通用

### 系统回收内存

当程序运行完毕, 操作系统将回收该内存空间, 并等待将此内存空间分配给其他程序使用, 但操作系统并**不清空**该内存空间中遗留下来的数据. 因此, 类似于 java 或者 go 这样的语言, 在声明变量时便会强制要求对变量进行赋值, 否则该变量所存储的数据是一些使用过的垃圾数据

## C/C++

### 指针与地址

指针变量是一个变量, 它的值是一个地址  
没有值的指针称为**野指针**, 不慎对其进行操作可能会引发严重的事故, 如更改到其他程序所使用的变量

### 指针加减

若 p 为指针变量, 则 `p + i == p + i * (p 所指向的变量所占的字节数)`

### 数组下标与数组引用
一维数组名是个指针常量, 其值为一维数组第一个元素的地址  
因此 : `a[i] == *(a + i)`

### 指针类型

指针变量要有类型的原因, 是因为指针内部存储的永远是**某个变量所占空间的第一个地址**, 而变量类型是各异的, 如 int char long struct 数组等等, 其所占空间大小也是各异的, 假如指针变量只保存某变量的首地址, 系统是无法判断该目标是什么类型的数据的, 这个首地址就被称为 **干地址**, 是无意义的, 因此指针变量需要指定其所包含的地址所记录的变量的类型

## Java

### 两同两小一大原则

* 方法名相同，参数类型相同  
* 子类返回类型小于等于父类方法返回类型，  
* 子类抛出异常小于等于父类方法抛出异常，  
* 子类访问权限大于等于父类方法访问权限。


### 静态全局变量的访问

通过类的对象来访问类变量时，实际不是访问该对象所拥有的变量，因为当系统创建该类的对象时，系统不会再为类变量分配内存，也不会再次对类变量进行初始化，也就是说，对象根本不拥有对应类的类变量，通过对象访问类变量只是一种假象，通过对象访问的依然是该类的类变量。


### 内存泄露与内存溢出

内存泄露主要有两种情况：

1. 在堆中申请的空间没有释放。
2. 对象已不再被使用  
    （注意：这里的不在被使用是指对程序来说没有用处，如数据库连接使用后没有关。但是还是存在着引用，但是仍然在内存中保留着）

GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。java语言中的内存泄露主要指第2种情况。

内存泄露的原因：

1. 静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。
2. 各种连接，如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。
3. 监听器，释放对象时往往没有相应的删除监听器，可能会导致内存泄露。

内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃这是结果描述。内存泄露（Memory Leak）最终会导致内存溢出。

### 类的实例化

虚拟机规范严格规定了有且只有五种情况必须立即对类进行初始化：

1. 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。

2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。

3. 当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。

4. 当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类；

5. 使用Jdk1.7动态语言支持的时候的一些情况。

除了这五种之外，其他的所有引用类的方式都不会触发初始化，称为被动引用：

1. 通过子类引用父类的的静态字段，不会导致子类初始化。

2. 通过数组定义来引用类，不会触发此类的初始化。

3. 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

### 类的定义修饰符

外部类：“Only public, abstract & final are permitted”

内部类：可以用修饰成员变量的修饰符修饰内部类 - static, private, protected